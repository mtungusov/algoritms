3-й поток

https://friendly-coin-3d9.notion.site/3-b035b1cd87b449d799babfe1fc4248c1
## Как решать задачи на курсе, чтобы это все было не зря
### План
1. Ставишь таймер
	- 20 мин. к этому времени нужно придумать хотя бы одно решение
	- 30 мин. должна быть решена задача
2. Открываешь задачу на leetcode и копируешь условие, примевы входных и выходных данных, ограничения (constraints) от туда в [Yandex Code](https://code.yandex-team.ru/) как комментарий + функцию/класс, который нужно написать или делаешь скриншот и смотришь на условие там. Вот пример для задачи [1. Two Sum](https://leetcode.com/problems/two-sum/) (~1 мин.)
3. Читаешь условие (~1.5 мин.)
4. Смотришь примеры и генерируешь один-два дополнительных тестовых кейсов и обязательно их записываешь (~0.5 мин.)
5. Думаешь над идеей (~5-20 мин.)
	- Думаешь над идеей и активно зарисовываешь/записываешь свои мысли, чтобы было проще думать. Даже не оптимальные решения можно записать если не получается придумать другой способ
	- Оцениваешь свое решение по времени и памяти и ЗАПИСЫВАЕШЬ это комментарием в коде
	- Думаешь можно ли оптимальнее и если кажется, что можно, то идешь к пункту a
	- Если 20-30 минут прошло, а идей 0, то сразу идем к пункту 7 и смотрим чужие решения и разбираемся, советую добавить эту задачу в RETRY LIST, (что это такое и как пользоваться расскажу в другой статье)
6. Пишешь код, даже если придумал не оптимальное решение, но время вышло (~5-10 мин.)
	- Пишешь код
	- Проверяешь только логику кода
	- Проверяешь только синтаксис
	- Если решение не прошло тест, то нужно занести это решение в ДНЕВНИК ОШИБОК (что это и зачем это нужно можно прочитать в другой статье)
7. Останавливаешь таймер
8. Убедится, что решение оптимально. Это можно сделать используя leetcode или в чатике спросить
9. Посмотреть другие решения. И если видите более “красивое” на ваш взгляд решение, то разобраться в нем
10. Сохранить свое решение в ДНЕВНИК УСПЕШНЫХ РЕШЕНИЙ (что это и зачем это нужно можно прочитать в другой статье)
11. Поздравляю, ты круто справился. Обязательно поделись своим ДНЕВНИКОМ УСПЕШНЫХ РЕШЕНИЙ в чатике в конце недели

## RETRY LIST, ДНЕВНИК ОШИБОК и РЕШЕНИЙ. Что это?
### Где вести все дневники
Советую для этого использовать [GitHub](https://github.com/) или [GitLab](https://gitlab.com/) и хранить все там. можно организовать структуру папок так:
```
/algorithms
   /retry-list
      README.md        <- список задачек, удаляем когда решили (RETRY LIST)
   /problems
      /array           <- имя темы
         ....
      /linked-list     <- имя темы
         /reverse-list <- имя задачи
            manual.md  <- тут код для оптимального решения + описание (ДНЕВНИК РЕШЕНИЙ)
            fails.md   <- тут все решения, которые были зафейлены (ДНЕВНИК ОШИБОК)
         /merge-lists
            manual.md
            fails.md <- тут
         ...
      ...
```

### ДНЕВНИК РЕШЕНИЙ
В конце каждой недели делимся дневниками решений и для того, чей дневник больше всего нравится - устраиваю БЕСПЛАТНУЮ ЛИЧНУЮ КОНСУЛЬТАЦИЮ по любым вопросам на 30 минут. В дальнейшем решения будут использоваться и для других потоков (после предварительной проверки)

Пожалуй, это самый главный из дневников, его смысл:
- зафиксировать правильное решение
- оценка по времени и памяти
- путь по которому вы пришли к решению

Этот дневник в дальнейшем будет служить вашей шпаргалкой на собеседованиях если вы что-то забыли(чужой дневник не может быть хорошей шпаргалкой, а свой - еще как может)

Следует соблюдать структуру:
- решение
- оценка по времени
- оценка по памяти
- ваши объяснения

#### Пример ДНЕВНИКА РЕШЕНИЙ (для задачи [1. Two Sum](https://leetcode.com/problems/two-sum/))

manual.md
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashmap = {}
        for i in range(len(nums)):
            complement = target - nums[i]
            if complement in hashmap:
                return [i, hashmap[complement]]
            hashmap[nums[i]] = i
```

##### Оценка по времени: O(n), где n - размер списка nums
Объяснения: делаем 1 проход по массиву, который образует n итераций, а на каждой итерации работаем со словарем, поиск и вставка в словаре работают за O(1), поэтому оценка по времени O(n)

##### Оценка по памяти: O(n), где n - размер списка nums
Объяснения: самый худший случай, когда ответ - последние 2 элемента. В этом случае у нас в словаре будут находится n-1 элементов, поэтому оценка по памяти O(n) (O(n), а не O(n-1) т к в big O нотации константы принято опускать)

##### Описание решения
Используем словарь для хранения позиции каждого элемента, где ключ - значение элементы массива, значение - позиция элемента. Eсли находим в словаре элемент равный target - nums[i], значит есть пара дающая в сумме target и возвращаем позицию элементов

### Дневник ошибок
Смысл данного дневника зафиксировать вообще все свои провальные отправки, а потом по возможности к ним вернуться и написать внизу каждой отправки что было не так.

Когда вы зафиксируете что было не так, то с большой вероятностью перестанете допускать такую ошибку в дальнейшем, а значит и шанс на отправку без ошибок вырастет.

### RETRY LIST
Это список задач, для которых вы не смогли придумать решение вообще в течении 30 минут. Туда кладем задачки сразу как не смогли решить (советую в READ.me группировать их по темам). Следует вернуться к этим задачкам через 1-2 дня и желательно еще раз через неделю-две, потом задачу из списка можно удалить если решение больше не вызывает никаких проблем.



